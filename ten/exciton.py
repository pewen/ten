"""
Excition Object
"""

import time
from math import e

import numpy as np

from .utils import generate_random_points_in_sphere

class Exciton(object):
    """
    Create a exciton inside of nanoparticle object.

    """
    def __init__(self, nanoparticle, num_exc, gen_exition, r_elec=0):
        """
        Create a exciton inside of nanoparticle object.

        Can be created at any place of the np with uniformal distribution
        using the method laser_generated() or by using a chemical electrolysis
        using electro_generated() method.

        Parameters
        ----------
        nanoparticle : object
            Nanoparticle objects.
        num_exc : float
            Numbers of exitation of the same nanoparticle.
        gen_exition : str
            Way to generate the exiton
        """
        self.nano_particle = nanoparticle
        self.num_exc = num_exc
        self.generation_exition = gen_exition
        self.r_electro = r_elec

        # Constante usada en el calculo de la probabilidad
        # la calculo una sola vez.
        self.cte_p_et = self.nano_particle.r_forster**6/self.nano_particle.tau_d


    def laser_generated(self):
        """
        Generate the random position of the exciton in any
        part of the nanoparticle, pretending that this is
        bombarded by a laser. Because the diameter of the
        nanoparticle is too small, it is assumed that all
        are bombarded with the same intensity.
        """
        point = generate_random_points_in_sphere(1, self.nano_particle.radius)
        self.position = point[0]


    def electro_generated(self):
        """
        The random position is generated by a chemical electrolysis.
        This position is generated between the radius R of the
        nanoparticle and a radius r, where r depends electrolysis.
        """
        point = generate_random_points_in_sphere(1, self.nano_particle.radius,
                                                 self.r_electro)
        self.position = point[0]


    def walk(self):
        """
        Exciton make a random walk inside the nanoparticle.
        Like in this case the radius is fixed (epsilon),
        the point of the random walk can generate using spherical coordinates.
        Then we'll have to check that taking this step,
        the exciton does not leave the nanoparticle
        """
        check = 1

        while check == 1:
            new_r = generate_random_points_in_sphere(1, self.nano_particle.epsilon,
                                                     self.nano_particle.epsilon)[0]

            new_dist = np.sqrt(sum((new_r + self.position)**2))
            if new_dist <= self.nano_particle.radius:
                check = 0

        self.position += new_r


    def k_et(self):
        """
        Energy transfer rate constant. Have the form:
        sum ((1 / tau_d)*(R_0 / r [i]) ** 6)
        where r[i] is the distance between the exciton
        and each acceptor and R_0 Forster radius.
        The sum go from 1 to M where M is the number of acceptors.

        Return
        ------
        k : float
          Probability to transfer the exciton to any acceptor
        """
        diff = self.position - self.nano_particle.acceptors_positions
        component_square = diff*diff
        one_over_distance = 1/(component_square[:, 0] + component_square[:, 1] +
                               component_square[:, 2])
        distance_6 = one_over_distance*one_over_distance*one_over_distance
        k = self.cte_p_et*sum(distance_6)

        return k


    def p_die(self):
        """
        Calculated the probability that a exciton is
        transferred to any acceptor.

        Return
        ------
        prob : float
             Probability that a exciton is transferred to the acceptor.
        """

        prob = 1 - np.e**-(self.nano_particle.delta_t*
                           (self.k_et() + 1/self.nano_particle.tau_d))

        return prob


    def quenching(self, each=True):
        """
        A random variable (VA) is compared with the probability of die (p_die).
        If the p_die > VA, the exciton decays. Else, the exciton make a
        random walk, and a VA is generated.
        """

        self.cant_decay = 0
        self.cant_transf = 0
        num_walk = 0

        time_ini = time.time()

        for cont in range(self.num_exc):
            check = 0

            # Dopamiento
            if self.nano_particle.generation_acceptors == 'sup':
                self.nano_particle.deposit_superficial_acceptors()
            else:
                self.nano_particle.deposit_volumetrically_acceptors()

            # Excition
            if self.generation_exition == 'elec':
                self.electro_generated()
            else:
                self.laser_generated()

            # Se ve si decae y luego en que forma
            while check == 0:
                if self.p_die() > np.random.random():
                    psi_et = self.k_et()/(self.k_et() + 1/self.nano_particle.tau_d)
                    if psi_et < np.random.random():
                        self.cant_decay += 1
                    else:
                        self.cant_transf += 1
                    check = 1
                else:
                    self.walk()
                    num_walk += 1

        self.walk_mean = num_walk/self.num_exc
        self.total_time = time.time() - time_ini
        self.efficiency = self.cant_transf / self.num_exc


    def l_d(self):
        """
        Calculated the exciton difusion length without any dopant.

        Many excitons are generated and the distance is calculated
        as the final position minus the initial. With these
        distances, an RMS average is made.

        Return
        ------
        l_d_rms : float
          RMS value of the L_D
        """

        positions_init = np.zeros((self.num_exc, 3))
        positions_end = np.zeros((self.num_exc, 3))

        for cont in range(self.num_exc):
            check = 0

            # This simulation is without aceptors
            self.position = generate_random_points_in_sphere(1, 1)[0]

            positions_init[cont] = self.position.copy()

            while check == 0:
                if self.p_die() > np.random.random():
                    check = 1
                else:
                    self.walk()

            positions_end[cont] = self.position.copy()

        dist = np.zeros(self.num_exc)
        dif_square = (positions_init - positions_end)*(positions_init -
                                                       positions_end)

        dist[:] = np.sqrt(dif_square[:, 0] + dif_square[:, 1] + dif_square[:, 2])
        l_d_rms = np.sqrt(sum(dist*dist)/self.num_exc)

        return l_d_rms


    def single_count(self):
        """
        Count the number of walk of each exciton.
        This is use to estimate tau.

        Return
        ------
        walk_array : array
          Each element is the number of walk
          for each excitation.
          len(walk_array) = number of excitations
        """
        walk_array = np.zeros(self.num_exc)

        for cont in range(self.num_exc):
            check = 0
            num_walk = 0

            # Excition
            self.laser_generated()

            while check == 0:
                rand_num = np.random.random()
                if self.nano_particle.p_decay > rand_num:
                    check = 1
                else:
                    self.walk()
                    num_walk += 1

            walk_array[cont] = num_walk

        return walk_array


    def get_input(self):
        """Return a list with the inputs parametes"""
        return [self.nano_particle.r_mean, self.nano_particle.r_deviation,
                self.nano_particle.r_forster, self.nano_particle.mean_path,
                self.nano_particle.tau_d, self.nano_particle.n_acceptors,
                self.nano_particle.epsilon, self.num_exc,
                self.nano_particle.delta_t, self.nano_particle.p_decay]


    def get_output(self):
        """Return a array with the output parameters"""
        return np.array([self.cant_decay, self.cant_transf,
                         self.efficiency, self.total_time,
                         self.walk_mean])
